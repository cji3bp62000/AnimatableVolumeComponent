using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.Rendering;

namespace TsukimiNeko.AnimatableVolumeComponent
{
    /// <summary>
    /// Code generator for AnimatableVolumeComponent and mapping.
    /// </summary>
    public static class AnimatableVolumeComponentCodeGenerator
    {
        public class VolumeParameterFieldInfo
        {
            public Type fieldType;
            public Type valueType;
            // may also be property name, but I will just call it field name
            public string volumeComponentFieldName;
            public string helperFieldName;

            public bool isVolumeComponentProperty;
            public bool isNonAnimatableType;
        }

        /// <summary>
        /// Types that can't be animated (due to technical limitations)
        /// </summary>
        private static readonly string[] NonAnimatableTypeNames = new[]
        {
            "TextureCurve",
        };

        /// <summary>
        /// Generate AnimatableVolumeComponent for the given VolumeComponent type.
        /// </summary>
        /// <param name="type">VolumeComponent type</param>
        public static void GenerateVolumeComponentHelperCode(Type type)
        {
            var vcType = typeof(VolumeComponent);
            if (!vcType.IsAssignableFrom(type)) {
                Debug.LogError($"{type.Name} does not inherit from {vcType.Name}!");
                return;
            }

            var fieldInfoList = new List<VolumeParameterFieldInfo>();
            FindParameters(type, ref fieldInfoList);

            var fieldIndent = "        ";
            var methodIndent = "            ";
            var fieldDeclareCode = "";
            var readMethodCode = "";
            var writeMethodCode = "";
            foreach (var fieldInfo in fieldInfoList) {
                // code generation for special case
                if (fieldInfo.isVolumeComponentProperty) {
                    // property only; we can't set the override value
                    fieldDeclareCode += $"{fieldIndent}public {GetFullName(fieldInfo.valueType)} {fieldInfo.helperFieldName};\n";
                    // strip the ".value" part
                    readMethodCode +=
                        $"{methodIndent}{fieldInfo.helperFieldName} = volumeComponent.{fieldInfo.volumeComponentFieldName};\n";
                    writeMethodCode +=
                        $"{methodIndent}volumeComponent.{fieldInfo.volumeComponentFieldName} = {fieldInfo.helperFieldName};\n";
                    continue;
                }
                else if (fieldInfo.isNonAnimatableType) {
                    // override state only; we can't set the value of non animatable types
                    fieldDeclareCode += $"{fieldIndent}public bool override_{fieldInfo.helperFieldName};\n";
                    readMethodCode +=
                        $"{methodIndent}override_{fieldInfo.helperFieldName} = volumeComponent.{fieldInfo.volumeComponentFieldName}.overrideState;\n";
                    writeMethodCode +=
                        $"{methodIndent}volumeComponent.{fieldInfo.volumeComponentFieldName}.overrideState = override_{fieldInfo.helperFieldName};\n";
                    continue;
                }

                // normal code generation
                // field definition
                fieldDeclareCode += $"{fieldIndent}public bool override_{fieldInfo.helperFieldName};\n";
                fieldDeclareCode += $"{fieldIndent}public {GetFullName(fieldInfo.valueType)} {fieldInfo.helperFieldName};\n";
                // read from profile
                readMethodCode +=
                    $"{methodIndent}override_{fieldInfo.helperFieldName} = volumeComponent.{fieldInfo.volumeComponentFieldName}.overrideState;\n";
                readMethodCode +=
                    $"{methodIndent}{fieldInfo.helperFieldName} = volumeComponent.{fieldInfo.volumeComponentFieldName}.value;\n";
                // write to profile
                writeMethodCode +=
                    $"{methodIndent}volumeComponent.{fieldInfo.volumeComponentFieldName}.overrideState = override_{fieldInfo.helperFieldName};\n";
                writeMethodCode +=
                    $"{methodIndent}volumeComponent.{fieldInfo.volumeComponentFieldName}.value = {fieldInfo.helperFieldName};\n";
            }

            var typeFullName = GetFullName(type);

            var generatedCode = $@"// <auto-generated />

using System;
using UnityEngine;
using UnityEngine.Rendering;

namespace TsukimiNeko.AnimatableVolumeComponent
{{
    [AnimatableOf(typeof({typeFullName}))]
    [DisallowMultipleComponent]
    public class Animatable{type.Name} : AnimatableVolumeComponentBase
    {{
        public override Type TargetType {{ get; }} = typeof({typeFullName});

{fieldDeclareCode}

        private void WriteToVolumeComponent({typeFullName} volumeComponent)
        {{
            if (!volumeComponent) return;

            volumeComponent.active = active;
{writeMethodCode}
        }}

        private void ReadFromVolumeComponent({typeFullName} volumeComponent)
        {{
            if (!volumeComponent) return;

            active = volumeComponent.active;
{readMethodCode}
        }}

        private void Reset()
        {{
            var volume = GetComponent<Volume>();
            if (!volume || !volume.sharedProfile || !volume.sharedProfile.TryGet<{typeFullName}>(out var volumeComponent)) return;

            ReadFromVolumeComponent(volumeComponent);
        }}

        public override void WriteToVolumeComponent()
        {{
            if (!volumeHelper.TryGet<{typeFullName}>(out var volumeComponent)) return;

            WriteToVolumeComponent(volumeComponent);
        }}

        public override void ReadFromVolumeComponent()
        {{
            if (!volumeHelper.TryGet<{typeFullName}>(out var volumeComponent)) return;

            ReadFromVolumeComponent(volumeComponent);
        }}
    }}
}}
";

            // 生成したコードをファイルに書き込む
            var path = $"{Application.dataPath}/AnimatableVolumeComponent/Generated/";
            var fileName = $"Animatable{type.Name}.cs";
            System.IO.Directory.CreateDirectory(path);
            Debug.Log($"writing to {path + fileName}");
            System.IO.File.WriteAllText(path + fileName, generatedCode);
        }

        /// <summary>
        /// One-layer-only VolumeParameter field searching
        /// </summary>
        /// <param name="targetVolumeComponentType"></param>
        /// <param name="parameterFieldList"></param>
        private static void FindParameters(Type targetVolumeComponentType, ref List<VolumeParameterFieldInfo> parameterFieldList)
        {
            // also search for NonPublic fields; if there is corresponding public property, we can use it
            var fields = targetVolumeComponentType
                .GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                .OrderBy(t => t.MetadataToken); // Guaranteed order
            var properties = targetVolumeComponentType
                .GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .ToArray();

            foreach (var field in fields) {
                if (!field.FieldType.IsSubclassOf(typeof(VolumeParameter))) continue;
                // skip obsolete fields
                if (field.GetCustomAttribute<ObsoleteAttribute>() != null) continue;

                var parameterValueType = GetVolumeParameterValueType(field.FieldType);
                var volumeComponentMemberName = field.Name;
                if (field.IsPublic == false) {
                    if (TryFindCorrespondingProperty(field, parameterValueType, properties, out var property)) {
                        volumeComponentMemberName = property.Name;
                    }
                    else {
                        // field not public and no corresponding property found; we can't access it
                        continue;
                    }
                }
                parameterFieldList.Add(new VolumeParameterFieldInfo()
                {
                    fieldType = field.FieldType,
                    valueType = parameterValueType,
                    volumeComponentFieldName = volumeComponentMemberName,
                    helperFieldName = field.Name,
                    isVolumeComponentProperty = !field.IsPublic,
                    isNonAnimatableType = NonAnimatableTypeNames.Contains(parameterValueType.Name),
                });
            }
        }

        /// <summary>
        /// Get "SomeType" from VolumeParameter＜SomeType＞ (or child class of VolumeParameter)
        /// </summary>
        /// <param name="volumeParameterType"></param>
        /// <returns>containing type</returns>
        private static Type GetVolumeParameterValueType(Type volumeParameterType)
        {
            var directChildType = volumeParameterType;
            while (!directChildType.IsGenericType || directChildType.GetGenericTypeDefinition() != typeof(VolumeParameter<>)) {
                directChildType = directChildType.BaseType;
                if (directChildType == null) {
                    return null;
                }
            }
            return directChildType.GetGenericArguments()[0];
        }

        /// <summary>
        /// If there is corresponding public property of field, return it.
        /// We can't precisely know if there is a corresponding property, so the result may be wrong. <br/>
        /// This check is mainly for HDRP default VolumeComponents that have private Parameter fields but corresponding
        /// public Properties.
        /// </summary>
        /// <param name="field"></param>
        /// <param name="fieldParameterValueType"></param>
        /// <param name="properties"></param>
        /// <param name="correspondingProperty"></param>
        /// <returns></returns>
        private static bool TryFindCorrespondingProperty(
            FieldInfo field,
            Type fieldParameterValueType,
            PropertyInfo[] properties,
            out PropertyInfo correspondingProperty)
        {
            correspondingProperty = null;
            var lowerCaseFieldName = field.Name.ToLower();
            foreach (var property in properties) {
                if (property.PropertyType != fieldParameterValueType) continue;
                var checkName = "m_" + property.Name.ToLower();
                if (lowerCaseFieldName == checkName) {
                    correspondingProperty = property;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Generate Mapping
        /// </summary>
        /// <param name="vcAvcMap"></param>
        /// <param name="vcList"></param>
        public static void GenerateMapCode(Dictionary<Type, Type> vcAvcMap, List<Type> vcList = null)
        {
            // existing Animatable Component map
            var mapDicItemCode = string.Join(
                "\n",
                vcAvcMap.Select(kvp => $"            Map[typeof({GetFullName(kvp.Key)})] = typeof({GetFullName(kvp.Value)});")
            );
            // just generated (not compiled) Animatable Component's original VolumeComponent list
            var listItemCode = "";
            if (vcList != null) {
                foreach (var type in vcList.Except(vcAvcMap.Keys)) {
                    var avcTypeFullName = $"TsukimiNeko.AnimatableVolumeComponent.Animatable{type.Name}";
                    listItemCode += $"            Map[typeof({GetFullName(type)})] = typeof({avcTypeFullName});\n";
                }
            }

            var generatedCode = $@"// <auto-generated />

using System;
using System.Collections.Generic;
using UnityEngine;

namespace TsukimiNeko.AnimatableVolumeComponent
{{
    public static partial class AnimatableVolumeComponentMapping
    {{
#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#endif
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void InitializeMap()
        {{
{mapDicItemCode}
{listItemCode}
        }}
    }}
}}
";

            var path = $"{Application.dataPath}/AnimatableVolumeComponent/Generated/";
            var fileName = "AnimatableVolumeComponentMapping.g.cs";
            System.IO.Directory.CreateDirectory(path);
            Debug.Log($"writing to {path + fileName}");
            System.IO.File.WriteAllText(path + fileName, generatedCode);
        }

        /// <summary>
        /// Get full name of type, replacing "+" with "."
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private static string GetFullName(Type type)
        {
            return type.FullName.Replace("+", ".");
        }
    }
}
